# ... (existing imports and setup code remains the same)

# --- New Asset Import Helpers ---
def import_glb(filepath: str, collection: bpy.types.Collection) -> list:
    """Import a GLB/GLTF file and link objects to the specified collection."""
    prev_objects = set(bpy.data.objects)
    try:
        bpy.ops.import_scene.gltf(filepath=os.path.abspath(filepath))
        imported_objects = [ob for ob in bpy.data.objects if ob not in prev_objects]
        
        # Link imported objects to the target collection
        for obj in imported_objects:
            # Unlink from default collection if needed
            for coll in obj.users_collection:
                if coll != collection:
                    coll.objects.unlink(obj)
            if obj.name not in collection.objects:
                collection.objects.link(obj)
        
        return imported_objects
    except Exception as e:
        print(f"{P_ERROR} Failed to import GLB file '{filepath}': {e}")
        return []

def link_blend_objects(blend_path: str, object_names: list, collection: bpy.types.Collection, link=True) -> list:
    """Link objects from a Blender file to the specified collection."""
    try:
        with bpy.data.libraries.load(os.path.abspath(blend_path), link=link) as (data_from, data_to):
            # If no specific object names provided, import all objects
            if not object_names:
                data_to.objects = data_from.objects
            else:
                data_to.objects = [name for name in object_names if name in data_from.objects]
        
        linked_objects = []
        for obj in data_to.objects:
            if obj is not None:
                collection.objects.link(obj)
                linked_objects.append(obj)
        
        return linked_objects
    except Exception as e:
        print(f"{P_ERROR} Failed to link objects from '{blend_path}': {e}")
        return []

def apply_basic_modifiers(obj: bpy.types.Object, modifiers_spec: dict):
    """Apply basic modifiers to an object based on a specification dictionary."""
    if not modifiers_spec or not isinstance(modifiers_spec, dict):
        return
    
    # Subdivision surface modifier
    if "SUBSURF" in modifiers_spec:
        subsurf_level = modifiers_spec["SUBSURF"]
        if isinstance(subsurf_level, int) and subsurf_level > 0:
            mod = obj.modifiers.new("Subsurf", "SUBSURF")
            mod.levels = subsurf_level
            mod.render_levels = subsurf_level
    
    # Bevel modifier
    if "BEVEL" in modifiers_spec:
        bevel_width = modifiers_spec["BEVEL"]
        if isinstance(bevel_width, (int, float)) and bevel_width > 0:
            mod = obj.modifiers.new("Bevel", "BEVEL")
            mod.width = float(bevel_width)
            mod.limit_method = 'ANGLE'
    
    # Decimate modifier
    if "DECIMATE" in modifiers_spec:
        decimate_ratio = modifiers_spec["DECIMATE"]
        if isinstance(decimate_ratio, (int, float)) and 0 < decimate_ratio < 1:
            mod = obj.modifiers.new("Decimate", "DECIMATE")
            mod.ratio = float(decimate_ratio)

def add_geometry_nodes(obj: bpy.types.Object, node_group_name: str, inputs: dict = None):
    """Add a geometry nodes modifier to an object."""
    if node_group_name not in bpy.data.node_groups:
        print(f"{P_WARN} Geometry node group '{node_group_name}' not found.")
        return
    
    mod = obj.modifiers.new(node_group_name, 'NODES')
    mod.node_group = bpy.data.node_groups[node_group_name]
    
    if inputs and isinstance(inputs, dict):
        for key, value in inputs.items():
            try:
                # Try to set the input value
                mod[key] = value
            except:
                print(f"{P_WARN} Could not set input '{key}' for geometry nodes modifier.")

# --- Enhanced ZW-MESH Handler ---
def handle_zw_mesh_block(mesh_data: dict, current_bpy_collection: bpy.types.Collection):
    if not bpy: 
        return None
    
    mesh_name = mesh_data.get("NAME", "UnnamedZWMesh")
    print(f"  Processing ZW-MESH: {mesh_name}")

    # Get mesh type and handle asset imports
    raw_type = mesh_data.get("TYPE", "cube")
    mesh_type = str(raw_type).strip().lower()
    
    # Check if this is an asset import
    source = mesh_data.get("SOURCE") or mesh_data.get("ASSET") or ""
    obj_name = mesh_data.get("OBJECT") or ""
    
    # Handle asset imports (GLB, BLEND files)
    if mesh_type == "asset" or mesh_type.startswith("mesh:") or mesh_type.startswith("asset:") or source:
        # Extract path and object name from type if source not explicitly provided
        if not source and ":" in str(raw_type):
            source = str(raw_type).split(":", 1)[1]
        
        # Split path and object name (format: path#object_name)
        path_part = source
        hash_obj = ""
        if "#" in source:
            path_part, hash_obj = source.split("#", 1)
        
        # Determine file type
        ext = os.path.splitext(path_part)[1].lower()
        
        imported_objects = []
        
        # Import based on file type
        if ext in (".glb", ".gltf"):
            imported_objects = import_glb(path_part, current_bpy_collection)
            # Filter by object name if specified
            if hash_obj:
                imported_objects = [obj for obj in imported_objects if obj.name == hash_obj]
        elif ext == ".blend":
            object_names = [hash_obj] if hash_obj else []
            imported_objects = link_blend_objects(path_part, object_names, current_bpy_collection)
        else:
            print(f"{P_WARN} Unknown asset extension '{ext}' for {source}.")
        
        if not imported_objects:
            print(f"{P_WARN} No objects imported from {source}, falling back to primitive.")
            # Fall through to primitive creation
        else:
            # Use the first imported object as our main object
            mesh_obj = imported_objects[0]
            mesh_obj.name = mesh_name
            
            # Apply transforms
            loc = safe_eval(mesh_data.get("LOCATION", "(0,0,0)"), (0, 0, 0))
            rot_deg = safe_eval(mesh_data.get("ROTATION", "(0,0,0)"), (0, 0, 0))
            scale_val = safe_eval(mesh_data.get("SCALE", "(1,1,1)"), (1, 1, 1))
            
            mesh_obj.location = loc
            mesh_obj.rotation_euler = Euler([math.radians(a) for a in rot_deg], 'XYZ')
            if isinstance(scale_val, (int, float)):
                mesh_obj.scale = (float(scale_val), float(scale_val), float(scale_val))
            else:
                mesh_obj.scale = scale_val
            
            # Apply modifiers if specified
            modifiers = mesh_data.get("MODIFIERS") or mesh_data.get("APPLY") or {}
            if isinstance(modifiers, dict):
                apply_basic_modifiers(mesh_obj, modifiers)
            
            # Apply geometry nodes if specified
            geo_nodes = mesh_data.get("GEOMETRY_NODES")
            if geo_nodes and isinstance(geo_nodes, str):
                geo_inputs = mesh_data.get("GN_INPUTS") or {}
                add_geometry_nodes(mesh_obj, geo_nodes, geo_inputs)
            
            # Apply material if specified
            material_def = mesh_data.get("MATERIAL")
            if isinstance(material_def, dict):
                if ZW_MESH_UTILS_IMPORTED and APPLY_ZW_MATERIAL_FUNC:
                    APPLY_ZW_MATERIAL_FUNC(mesh_obj, material_def)
                else:
                    print(f"{P_WARN} Material definition found but zw_mesh.apply_material not available.")
            
            # Apply metadata if specified
            metadata_dict = mesh_data.get("METADATA")
            if isinstance(metadata_dict, dict):
                handle_zw_metadata_block(metadata_dict, target_obj_name=mesh_obj.name)
            
            print(f"    ✅ Successfully imported asset: {mesh_name} from {source}")
            return mesh_obj
    
    # Handle primitive types (existing code)
    base_type = mesh_type
    params = mesh_data.get("PARAMS", {})
    
    # Create base primitive
    if base_type == "cube":
        bpy.ops.mesh.primitive_cube_add(size=float(params.get("SIZE", 1.0)))
    elif base_type == "ico_sphere":
        bpy.ops.mesh.primitive_ico_sphere_add(
            subdivisions=int(params.get("SUBDIVISIONS", 2)),
            radius=float(params.get("RADIUS", 1.0)))
    elif base_type == "cylinder":
        bpy.ops.mesh.primitive_cylinder_add(
            vertices=int(params.get("VERTICES", 32)),
            radius=float(params.get("RADIUS", 1.0)),
            depth=float(params.get("DEPTH", 2.0)))
    elif base_type == "cone":
        bpy.ops.mesh.primitive_cone_add(
            vertices=int(params.get("VERTICES", 32)),
            radius1=float(params.get("RADIUS1", params.get("RADIUS", 1.0))),
            depth=float(params.get("DEPTH", 2.0)))
    elif base_type == "plane":
        bpy.ops.mesh.primitive_plane_add(size=float(params.get("SIZE", 2.0)))
    else:
        print(f"    {P_WARN} Unknown ZW-MESH base TYPE '{base_type}'. Defaulting to Cube.")
        bpy.ops.mesh.primitive_cube_add(size=1.0)

    mesh_obj = bpy.context.active_object
    if not mesh_obj:
        print(f"    {P_ERROR} Failed to create base primitive for ZW-MESH '{mesh_name}'.")
        return None
    
    mesh_obj.name = mesh_name
    
    # Apply transforms
    loc = safe_eval(mesh_data.get("LOCATION", "(0,0,0)"), (0, 0, 0))
    rot_deg = safe_eval(mesh_data.get("ROTATION", "(0,0,0)"), (0, 0, 0))
    scale_val = safe_eval(mesh_data.get("SCALE", "(1,1,1)"), (1, 1, 1))
    
    mesh_obj.location = loc
    mesh_obj.rotation_euler = Euler([math.radians(a) for a in rot_deg], 'XYZ')
    if isinstance(scale_val, (int, float)):
        mesh_obj.scale = (float(scale_val), float(scale_val), float(scale_val))
    else:
        mesh_obj.scale = scale_val
    
    # Apply material properties
    material_def = mesh_data.get("MATERIAL")
    if isinstance(material_def, dict):
        mat_name = material_def.get("NAME", f"{mesh_name}_Material")
        mat = bpy.data.materials.get(mat_name)
        if not mat: 
            mat = bpy.data.materials.new(name=mat_name)
        
        if not mesh_obj.data.materials:
            mesh_obj.data.materials.append(mat)
        else:
            mesh_obj.data.materials[0] = mat
        
        mat.use_nodes = True
        bsdf = mat.node_tree.nodes.get("Principled BSDF")
        if not bsdf:
            bsdf = mat.node_tree.nodes.new(type='ShaderNodeBsdfPrincipled')
            output_node = mat.node_tree.nodes.get('Material Output')
            if not output_node: 
                output_node = mat.node_tree.nodes.new('ShaderNodeOutputMaterial')
            mat.node_tree.links.new(bsdf.outputs['BSDF'], output_node.inputs['Surface'])

        if "BASE_COLOR" in material_def: 
            bsdf.inputs["Base Color"].default_value = parse_color(material_def["BASE_COLOR"])
        if "EMISSION_STRENGTH" in material_def: 
            bsdf.inputs["Emission Strength"].default_value = float(material_def["EMISSION_STRENGTH"])
        elif "EMISSION" in material_def: 
            bsdf.inputs["Emission Strength"].default_value = float(material_def["EMISSION"])
        if "EMISSION_COLOR" in material_def: 
            bsdf.inputs["Emission Color"].default_value = parse_color(material_def["EMISSION_COLOR"])
        if "ROUGHNESS" in material_def: 
            bsdf.inputs["Roughness"].default_value = float(material_def["ROUGHNESS"])
        if "METALLIC" in material_def: 
            bsdf.inputs["Metallic"].default_value = float(material_def["METALLIC"])
        if "TRANSMISSION" in material_def: 
            bsdf.inputs["Transmission"].default_value = float(material_def["TRANSMISSION"])
        if "ALPHA" in material_def: 
            bsdf.inputs["Alpha"].default_value = float(material_def["ALPHA"])
        if "SPECULAR" in material_def: 
            bsdf.inputs["Specular IOR Level"].default_value = float(material_def["SPECULAR"])

    # Apply Metadata (if any)
    metadata_dict = mesh_data.get("METADATA")
    if isinstance(metadata_dict, dict):
        handle_zw_metadata_block(metadata_dict, target_obj_name=mesh_obj.name)

    # Link to collection
    explicit_coll_name = mesh_data.get("COLLECTION")
    target_collection = current_bpy_collection
    if explicit_coll_name:
        target_collection = get_or_create_collection(explicit_coll_name, bpy.context.scene.collection)

    # Unlink from default collection and link to target
    for coll in mesh_obj.users_collection:
        coll.objects.unlink(mesh_obj)
    if mesh_obj.name not in target_collection.objects:
        target_collection.objects.link(mesh_obj)
    
    print(f"    ✅ Successfully created ZW-MESH: {mesh_name}")
    return mesh_obj

# --- Un-stubbed Light Handler ---
def handle_zw_light_block(light_data: dict, current_bpy_collection=None):
    """Create a Blender light from a ZW-LIGHT definition."""
    if not bpy:
        return None
    
    if not isinstance(light_data, dict):
        print(f"{P_WARN} ZW-LIGHT data should be a dict, got {type(light_data)}")
        return None
    
    light_name = str(light_data.get("NAME", "ZW_Light")).strip('"\' ')
    light_type = str(light_data.get("TYPE", "POINT")).strip('"\' ').upper()
    
    # Map ZW light types to Blender light types
    type_mapping = {
        "POINT": "POINT",
        "SUN": "SUN",
        "SPOT": "SPOT",
        "AREA": "AREA"
    }
    blender_light_type = type_mapping.get(light_type, "POINT")
    
    # Create light data
    light_data_block = bpy.data.lights.new(name=light_name, type=blender_light_type)
    
    # Set light properties
    energy = safe_eval(light_data.get("ENERGY", "1000"), 1000)
    color = parse_color(light_data.get("COLOR", "(1,1,1,1)"))
    size = safe_eval(light_data.get("SIZE", "0.1"), 0.1)
    
    light_data_block.energy = float(energy)
    light_data_block.color = color[:3]  # RGB only
    light_data_block.shadow_soft_size = float(size)
    
    # Handle specific light type properties
    if blender_light_type == "SPOT":
        angle = safe_eval(light_data.get("ANGLE", "45"), 45)
        blend = safe_eval(light_data.get("BLEND", "0.15"), 0.15)
        light_data_block.spot_size = math.radians(float(angle))
        light_data_block.spot_blend = float(blend)
    
    elif blender_light_type == "AREA":
        shape = str(light_data.get("SHAPE", "SQUARE")).strip('"\' ').upper()
        size_x = safe_eval(light_data.get("SIZE_X", "1"), 1)
        size_y = safe_eval(light_data.get("SIZE_Y", "1"), 1)
        
        shape_mapping = {
            "SQUARE": "SQUARE",
            "RECTANGLE": "RECTANGLE",
            "DISK": "DISK",
            "ELLIPSE": "ELLIPSE"
        }
        light_data_block.shape = shape_mapping.get(shape, "SQUARE")
        light_data_block.size = float(size_x)
        if light_data_block.shape == "RECTANGLE" or light_data_block.shape == "ELLIPSE":
            light_data_block.size_y = float(size_y)
    
    # Create light object
    light_obj = bpy.data.objects.new(name=light_name, object_data=light_data_block)
    
    # Set transform
    loc = safe_eval(light_data.get("LOCATION", "(0,0,0)"), (0, 0, 0))
    rot_deg = safe_eval(light_data.get("ROTATION", "(0,0,0)"), (0, 0, 0))
    
    light_obj.location = loc
    light_obj.rotation_euler = Euler([math.radians(a) for a in rot_deg], 'XYZ')
    
    # Link to collection
    target_collection = current_bpy_collection or bpy.context.scene.collection
    target_collection.objects.link(light_obj)
    
    print(f"{P_INFO} Created light: {light_name} ({blender_light_type})")
    return light_obj

# --- Un-stubbed Camera Handler ---
def handle_zw_camera_block(camera_data: dict, current_bpy_collection=None):
    """Create a Blender camera from a ZW-CAMERA definition."""
    if not bpy:
        return None
    
    if not isinstance(camera_data, dict):
        print(f"{P_WARN} ZW-CAMERA data should be a dict, got {type(camera_data)}")
        return None
    
    camera_name = str(camera_data.get("NAME", "ZW_Camera")).strip('"\' ')
    
    # Create camera data
    camera_data_block = bpy.data.cameras.new(name=camera_name)
    
    # Set camera properties
    focal_length = safe_eval(camera_data.get("FOCAL_LENGTH", "50"), 50)
    sensor_width = safe_eval(camera_data.get("SENSOR_WIDTH", "36"), 36)
    sensor_height = safe_eval(camera_data.get("SENSOR_HEIGHT", "24"), 24)
    
    camera_data_block.lens = float(focal_length)
    camera_data_block.sensor_width = float(sensor_width)
    camera_data_block.sensor_height = float(sensor_height)
    
    # Handle camera type (perspective vs orthographic)
    camera_type = str(camera_data.get("TYPE", "PERSPECTIVE")).strip('"\' ').upper()
    if camera_type == "ORTHOGRAPHIC":
        camera_data_block.type = "ORTHO"
        ortho_scale = safe_eval(camera_data.get("ORTHO_SCALE", "6.0"), 6.0)
        camera_data_block.ortho_scale = float(ortho_scale)
    
    # Create camera object
    camera_obj = bpy.data.objects.new(name=camera_name, object_data=camera_data_block)
    
    # Set transform
    loc = safe_eval(camera_data.get("LOCATION", "(0,0,0)"), (0, 0, 0))
    rot_deg = safe_eval(camera_data.get("ROTATION", "(0,0,0)"), (0, 0, 0))
    
    camera_obj.location = loc
    camera_obj.rotation_euler = Euler([math.radians(a) for a in rot_deg], 'XYZ')
    
    # Link to collection
    target_collection = current_bpy_collection or bpy.context.scene.collection
    target_collection.objects.link(camera_obj)
    
    print(f"{P_INFO} Created camera: {camera_name}")
    return camera_obj

# ... (rest of the file remains the same)